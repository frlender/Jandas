import { ns, ns_arr, numx, nsx, locParamArr, SeriesInitOptions, SeriesRankOptions, RollingOptions } from './interfaces';
import Index from './Index';
import { SeriesRolling } from './df_lib';
declare class Series<T> {
    values: T[];
    private _index;
    shape: number;
    private _name;
    constructor(values: T[]);
    constructor(values: T[], options: SeriesInitOptions);
    constructor(values: T[], options?: SeriesInitOptions);
    get index(): Index;
    set index(vals: ns_arr | Index);
    get name(): string | number;
    set name(val: string | number);
    rename(labelMap: {
        [key: ns]: ns;
    }, inplace: true): void;
    rename(labelMap: {
        [key: ns]: ns;
    }, inplace: false): Series<T>;
    rename(labelMap: {
        [key: ns]: ns;
    }, inplace?: boolean): void | Series<T>;
    p(): void;
    _iloc(idx: number): T;
    _iloc(idx: undefined | number[] | boolean[]): Series<T>;
    _iloc(idx?: numx | boolean[]): T | Series<T>;
    iloc(idx: number): T;
    iloc(idx?: string | number[] | boolean[]): Series<T>;
    iloc(idx?: string | numx | boolean[]): T | Series<T>;
    loc(index: number | string): T | Series<T>;
    loc(index?: locParamArr): Series<T>;
    loc(index?: (number | string) | locParamArr): T | Series<T>;
    _iset(idx: undefined | numx | boolean[], values: T | T[]): void;
    iset(rpl: T[]): void;
    iset(index: number, rpl: T): void;
    iset(index: string | number[] | boolean[], rpl: T[]): void;
    iset(first: T[] | string | numx | boolean[], second?: T | T[]): void;
    set(rpl: T[]): void;
    set(idx: string | number, rpl: T | T[]): void;
    set(idx: locParamArr, rpl: T[]): void;
    set(first: T[] | string | numx | locParamArr, second?: T | T[]): void;
    push(val: T, name?: number | string): void;
    insert(idx: number, val: T, name?: number | string): void;
    drop(labels: nsx): Series<T>;
    drop_duplicates(keep?: 'first' | 'last' | false): Series<T>;
    bool(expr: string): boolean[];
    b(expr: string, __ctx__?: any): boolean[];
    query(expr: string, ctx?: any): Series<T>;
    q(expr: string, ctx?: any): Series<T>;
    sort_values(ascending?: boolean): Series<T>;
    value_counts(): Series<number>;
    op<K>(opStr: string | ((x: T) => K)): Series<K>;
    op<K, Z>(opStr: string | ((x: T, y: Z) => K), ss: Series<Z> | Z[]): Series<K>;
    unique(): T[];
    rank(this: Series<number>, options?: SeriesRankOptions): Series<number>;
    change(this: Series<number>, op_str: string, periods?: number): Series<number>;
    diff(this: Series<number>, periods?: number): Series<number>;
    pct_change(this: Series<number>, periods?: number): Series<number>;
    rolling(this: Series<number>, window: number, { min_periods, center, closed, step }?: RollingOptions): SeriesRolling;
    isna(): Series<boolean>;
    reduce<K>(func: (a: T[]) => K): K;
    min(this: Series<number>): number;
    max(this: Series<number>): number;
    sum(this: Series<number>): number;
    mean(this: Series<number>): number;
    mode(this: Series<number>): number;
    median(this: Series<number>): number;
    std(this: Series<number>): number;
    var(this: Series<number>): number;
    prod(this: Series<number>): number;
    to_raw(copy?: boolean): {
        values: T[];
        name: string | number;
        index: {
            values: (string | number)[];
            name: string | number;
        };
    };
}
export default Series;
